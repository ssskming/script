#!/bin/bash

# fifo
# Thread
# 关键疑问：为什么不对管道符进行控制操作？
# 因为管道符必须同时有读写时才不会停滞，当我们要echo空行时，因为没有读取就会停滞
# 无法实现读写分离，当没有后续任务或后续任务暂时不能读到空行启动时，就无法向管道中输入空行
# 那么后面的代码就无法执行，整个流程就会产生中断。
# 而文件操作符不会因为没有读取就停滞，大概空行会暂存在文件操作符中，而文件操作符又与管道符绑定
# 输入空行命令之后，本线程后续代码也可以断续执行。
# 当有新的任务来时，读取了文件操作符的内容，原来停滞在文件操作符中的空行就输出到了管道中，流程就通了
# 当所有任务完成了，没有后续任务时，就关闭了文件操作符，同时那个已删除的管道就彻底消失了。

# 接受信号 2 （ctrl +C）做的操作
# trap命令允许你来指定shell脚本要监视并拦截的Linux信号。
# trap命令的格式为：trap commands signals。
# 2	SIGINT	终止进程
# 18	SIGTSTP	停止或暂停进程，但不终止进程
# 19	SIGCONT	继续运行停止的进程
# exec 1000>&-和exec 1000<&- 是关闭fd1000的意思
# 我们生成做绑定时 可以用 exec 1000<>testfifo 来实现，但关闭时必须分开来写
# > 读的绑定，< 标识写的绑定  <> 则标识 对文件描述符 
# 1000的所有操作等同于对管道文件 testfifo的操作。

trap "exec 1000>&-;exec 1000<&-;exit 0" 2

# 创建管道文件，文件操作符绑定，删除管道文件
# 不对管道文件进行操作，是因为管道读写必须同时存在，否则会滞留
# 绑定了文件操作符，对文件操作符进行操作就不会有这样的问题
# 管道不会因为这里的删除而消失，必须是完成操作完毕才会消失
# 所以文件操作符不关闭，管道文件还在起作用，只用操作完毕才会自动消失
# 这样后续就不用再考虑管道符的事情了，直接操作文件操作符就行了。
mkfifo testfifo
exec 1000<>testfifo
rm -rf testfifo

# 对文件操作符进行写入操作，写入10个空行
# 10代表要定义的后台进程数
# 管道文件的读取是以行为单位的
# 后续读取空行会比较方便
# 另外 >&1000 也可以写在done外面
# 里面是对单次循环输出，外面是对整个for循环输出，效果一样

for((n=1;n<=10;n++))
do
	echo >&1000
done

start=`date "+%s"`

# 总任务个数100
# read -u1000 读取1000文件操作符(testfifo管道符中,删除但是没有消失)中的一行
# 只有读到空行了才会断续运行下面的任务
# 任务完成要向文件操作符中再输入一行空行
# 保证后续的任务有空行可读才行

for((i=1;i<=100;i++))
do
	read -u1000
	{
		# 要放入后台运行的任务 不需要用 & 来放入后台了，本身就是压入后台并发运行的。
		echo success$i;sleep 5
		echo >&1000
	}&
done

# 等待所有任务完成才向下执行
wait

end=`date "+%s"`

echo "TIME: `expr $end - $start`"

# 下面两条命令是关闭文件操作符
exec 1000>&-
exec 1000<&-
